{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/customtheme/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/customtheme/source/images/avatar.svg","path":"images/avatar.svg","modified":1,"renderable":1},{"_id":"themes/customtheme/source/images/ic-fb.png","path":"images/ic-fb.png","modified":1,"renderable":1},{"_id":"themes/customtheme/source/images/ic-linkedin.png","path":"images/ic-linkedin.png","modified":1,"renderable":1},{"_id":"themes/customtheme/source/images/ic-skype.png","path":"images/ic-skype.png","modified":1,"renderable":1}],"Cache":[{"_id":"themes/customtheme/_config.yml","hash":"34139ac66e031c4a684547eacd9a56a801d44fb5","modified":1559318435477},{"_id":"source/_posts/Tim-hieu-Higher-Order-Component-trong-React.md","hash":"3b9b8d0c504a96eadffbfb3ccd0980229a356d44","modified":1559468976032},{"_id":"source/_posts/deploy-voi-heroku.md","hash":"9383f2115452dcd3032dd8b162febb596adb89ae","modified":1559386816746},{"_id":"themes/customtheme/layout/index.ejs","hash":"ef369bb991fffa693e0f758f697523a41d0ca569","modified":1559385625428},{"_id":"themes/customtheme/layout/layout.ejs","hash":"6434378bd336f86aa67f35a560bfc5cc4ca7fdb0","modified":1559468615341},{"_id":"themes/customtheme/layout/post.ejs","hash":"99739bd09a35501a25eb2eb626f4bcbd51478fb4","modified":1559384777230},{"_id":"themes/customtheme/layout/_partial/head.ejs","hash":"b0e5e5cd70d73fb212cf8898d961d7d9ff8226fe","modified":1559318435478},{"_id":"themes/customtheme/source/css/_variables.styl","hash":"c3463c4129e00238c42722443ca8148620c07421","modified":1559384893873},{"_id":"themes/customtheme/source/css/style.styl","hash":"1a5158a4ae63a4452e626b1a7466fec568fcb991","modified":1559468531650},{"_id":"themes/customtheme/source/images/avatar.svg","hash":"9a3b4386d7be9a7fc6cdb153fd0594055d8f735c","modified":1559318435482},{"_id":"themes/customtheme/source/images/ic-fb.png","hash":"7d34f13a264eb5eb8bd10d772da37d4bc6553cda","modified":1559442751363},{"_id":"themes/customtheme/source/images/ic-linkedin.png","hash":"88183ccadee6513ea96155fd672469dc77cabcd8","modified":1559442773272},{"_id":"themes/customtheme/source/images/ic-skype.png","hash":"4ff42a9432364f1b85ae2e937979ccbf517187a8","modified":1559442760486},{"_id":"themes/customtheme/source/css/_partial/article.styl","hash":"6b6a443ab8d5d58e38455ec9235b1277a3f88e35","modified":1559386419645},{"_id":"themes/customtheme/source/css/_util/mixin.styl","hash":"14f948d6033b7f1844a0cfa235af35d4664ced79","modified":1559373776881}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Deploy sử dụng Heroku","date":"2019-06-01T08:21:19.000Z","_content":"\nHeroku cung cấp dịch vụ máy chủ đám mây giúp dễ dàng trong việc deploy ứng dụng. Điều tuyệt vời ở Heroku là trang này bạn có thể sử dụng dịch vụ hoàn toàn miễn phí với các ứng dụng web không yêu cầu phải có tốc độ truy cập cao hay dung lượng lớn.\n\nTrong bài học này chúng ta sẽ\n  + Tạo một dự án trên heroku\n  + Cấu hình git server repository cho phía local\n  + Deploy ứng dụng\n\n### Tạo dự án trên heroku\n\nĐể tạo dự án trên Heroku, bạn cần tạo một tài khoản (hoàn toàn miễn phí) sau đó kích hoạt và đăng nhập vào địa chỉ https://dashboard.heroku.com/. Sau khi đăng nhập vào địa chỉ này, bạn sẽ thấy có một icon hình dấu cộng dùng để tạo dự án. Click vào icon này và chọn Create new app:\n\n![alt text](https://i.imgur.com/OiXd6go.png \"heroku deploy\")\n\nTrong mục App name chọn tên cho ứng dụng nếu bạn để trống Heroku sẽ chọn ngẫu nhiên một tên cho ứng dụng. Tiếp theo có 2 lựa chọn để chọn vùng cho server Heroku sẽ host ứng dụng là Mỹ và Châu Âu. Với các ứng dụng ở Việt Nam thì bạn nên chọn Europe để nâng cao tốc độ truy cập. Sau đó, bấm Create app.\n![alt text](https://i.imgur.com/S1Up7Xu.png \"Create app heroku\")\n\n\n### Tạo Git Repository Trên Máy Local\n\nBây giờ trên máy tính local, chúng ta cần khởi tạo Git local repository (hay local repo). Local repo giống như một cái kho, nơi chứa source code mà bạn sẽ dùng để phát triển dụng. Trên terminal di chuyển tới thư mục ứng dụng ở máy tính bạn và chạy câu lệnh sau:\n\n``` bash\n  $ git init\n```\n\nCâu lệnh này dùng để khởi tạo một dự án Git ở trên máy tính local (hay còn gọi là local repo). Tiếp theo chạy câu lệnh sau để xem trạng thái (status) của các file trên local repo này:\n\n``` bash\n  $ git status\n```\n\nBạn sẽ thấy kết quả như sau:\n``` bash\n  # On branch master\n  #\n  # Initial commit\n  #\n  # Untracked files:\n  #   (use \"git add <file>...\" to include in what will be committed)\n  #\n  #   node_modules/\n  #   npm-debug.log\n  #   package.json\n  nothing added to commit but untracked files present (use \"git add\" to track)\n```\n\nỞ đây, Git nói với bạn có 2 file và 1 thư mục chưa được theo dõi (tracked) và để thêm chúng vào bạn cần chạy câu lệnh git add.\n\nTuy nhiên, khi làm việc với ứng dụng Nodejs nói chung và Expressjs framework nói riêng, chúng ta không nên thêm file npm-debug.log và thư mục node_modules/ vào trong Git vì nội dung của 2 file này sẽ khác nhau phụ thuộc vào hệ điều hành mỗi lập trình viên sử dụng. Để Git không theo doi 2 file này, chúng ta tạo một file .gitignore với nội dung như sau:\n\n```bash\n/npm-debug.log\n/node_modules/\n```\n\nĐể thêm tất cả các file hiện có trong thư mục của ứng dụng. Bây giờ nếu bạn chạy câu lệnh git statusbạn sẽ chỉ thấy Git thông báo 1 file cần được thêm vào là package.json:\n\n```bash\n# On branch master\n#\n# Initial commit\n#\n# Untracked files:\n#   (use \"git add <file>...\" to include in what will be committed)\n#\n#   .gitignore\n#   package.json\n```\n\nTiếp theo chạy câu lệnh sau để thêm tất cả các file có trong thư mục dự án vào Git:\n\n```bash\n$ git add .\n```\n\nChạy git status một lần nữa để kiểm tra trạng thái của các file. Lúc này bạn sẽ thấy Git đánh dấu các file vừa được thêm vào bằng màu khác với trước đó:\n\n![alt text](https://i.imgur.com/GIdBjii.jpg \"github\")\n\nCuối cùng, chúng ta hãy tạo một commit đầu tiên sử dụng câu lệnh:\n\n```bash\n$ git commit -m 'First commit'\n```\n\nở đây, option -m được sử dụng để tạo message cho commit. Message này thường là nội dung tóm tắt mô tả xem commit thay đổi những gì trong source code. Vì đây là commit đầu tiên nên tôi chỉ đơn giản để là First commit.\n\n### Cấu Hình Git Repository\n\nKhi bạn tạo một ứng dụng sử dụng giao diện web trên trang Heroku, lúc này Heroku sẽ tạo cho bạn sẽ có một Git server repository (repo server). Repo server là một kho chứa code nhưng nó khác với local ở chỗ mọi lập trình viên trong dự án đều có thể để có thể đấy (push) source code lên trên đó hoặc kéo (pull) code của người khác về để cập nhật những thay đổi tạo ra bởi người khác. Để tìm thấy địa chỉ đường dẫn cho repository trên server Heroku này, vào trong trang quản lý app (dùng giao diện web trên Heroku) bạn click vào tab Settings. Ở đây bạn sẽ tìm thấy địa chỉ URL này, của tôi như sau:\n\n```bash\ngit@heroku.com:hoclaptrinh-expressjs-mongo.git\n```\n\nTiếp theo, để cấu hình URL này là server repo cho local repo, chạy câu lệnh sau:\n\n```bash\n$ git remote add origin git@heroku.com:hoclaptrinh-expressjs-mongo.git\n```\n\nĐể kiểm tra lại thông tin của repo server xem có chính xác hay chưa, chạy câu lệnh:\n\n```bash\n$ git remote -v\n```\nỞ đây option -v là viết tắt của từ verbose\n\n### Deploy Ứng Dụng\n\nĐể deploy ứng dụng lên Heroku, bạn cần cài đặt Heroku Toolbelt. Bạn có thể xem hướng dẫn về cách cài đặt Heroku Toolbelt ở bài viết Cài đặt và sử dụng Heroku Toolbelt.\n\nSau khi cài đặt xong Heroku Toolbelt bạn cần thêm ssh key để có thể đấy source code lên server. Để thêm ssh key chạy câu lệnh sau:\n\n```bash\n$ heroku keys:add\n```\n\nCuối cùng bạn có thể deploy source code lên Heroku bằng cách chạy câu lệnh:\n\n\n```bash\n$ git push -u origin master\n```\n\nKhi đấy souce code lần đầu tiên lên trên server bạn nên sử dụng option -uđể Git hiểu rằng repo server này sẽ theo dõi master branch của repo local. Trong các lần push source code tiếp theo bạn có thể làm đơn giản hơn bằng câu lệnh:\n\n```bash\n$ git push origin\n```\n\nLúc này Git hiểu rằng bạn muốn đẩy source code trong master local branch lên origin remote brach mà không cần phải thêm master vào trong câu lệnh.\nSau khi kết thúc việc push source code, Heroku sẽ tự động deploy ứng dụng cho bạn.\n\n<div style=\"text-align: right\">**Nguồn: Code Hub**</div>\n","source":"_posts/deploy-voi-heroku.md","raw":"---\ntitle: Deploy sử dụng Heroku\ndate: 2019-06-01 15:21:19\ntags: lalala\n---\n\nHeroku cung cấp dịch vụ máy chủ đám mây giúp dễ dàng trong việc deploy ứng dụng. Điều tuyệt vời ở Heroku là trang này bạn có thể sử dụng dịch vụ hoàn toàn miễn phí với các ứng dụng web không yêu cầu phải có tốc độ truy cập cao hay dung lượng lớn.\n\nTrong bài học này chúng ta sẽ\n  + Tạo một dự án trên heroku\n  + Cấu hình git server repository cho phía local\n  + Deploy ứng dụng\n\n### Tạo dự án trên heroku\n\nĐể tạo dự án trên Heroku, bạn cần tạo một tài khoản (hoàn toàn miễn phí) sau đó kích hoạt và đăng nhập vào địa chỉ https://dashboard.heroku.com/. Sau khi đăng nhập vào địa chỉ này, bạn sẽ thấy có một icon hình dấu cộng dùng để tạo dự án. Click vào icon này và chọn Create new app:\n\n![alt text](https://i.imgur.com/OiXd6go.png \"heroku deploy\")\n\nTrong mục App name chọn tên cho ứng dụng nếu bạn để trống Heroku sẽ chọn ngẫu nhiên một tên cho ứng dụng. Tiếp theo có 2 lựa chọn để chọn vùng cho server Heroku sẽ host ứng dụng là Mỹ và Châu Âu. Với các ứng dụng ở Việt Nam thì bạn nên chọn Europe để nâng cao tốc độ truy cập. Sau đó, bấm Create app.\n![alt text](https://i.imgur.com/S1Up7Xu.png \"Create app heroku\")\n\n\n### Tạo Git Repository Trên Máy Local\n\nBây giờ trên máy tính local, chúng ta cần khởi tạo Git local repository (hay local repo). Local repo giống như một cái kho, nơi chứa source code mà bạn sẽ dùng để phát triển dụng. Trên terminal di chuyển tới thư mục ứng dụng ở máy tính bạn và chạy câu lệnh sau:\n\n``` bash\n  $ git init\n```\n\nCâu lệnh này dùng để khởi tạo một dự án Git ở trên máy tính local (hay còn gọi là local repo). Tiếp theo chạy câu lệnh sau để xem trạng thái (status) của các file trên local repo này:\n\n``` bash\n  $ git status\n```\n\nBạn sẽ thấy kết quả như sau:\n``` bash\n  # On branch master\n  #\n  # Initial commit\n  #\n  # Untracked files:\n  #   (use \"git add <file>...\" to include in what will be committed)\n  #\n  #   node_modules/\n  #   npm-debug.log\n  #   package.json\n  nothing added to commit but untracked files present (use \"git add\" to track)\n```\n\nỞ đây, Git nói với bạn có 2 file và 1 thư mục chưa được theo dõi (tracked) và để thêm chúng vào bạn cần chạy câu lệnh git add.\n\nTuy nhiên, khi làm việc với ứng dụng Nodejs nói chung và Expressjs framework nói riêng, chúng ta không nên thêm file npm-debug.log và thư mục node_modules/ vào trong Git vì nội dung của 2 file này sẽ khác nhau phụ thuộc vào hệ điều hành mỗi lập trình viên sử dụng. Để Git không theo doi 2 file này, chúng ta tạo một file .gitignore với nội dung như sau:\n\n```bash\n/npm-debug.log\n/node_modules/\n```\n\nĐể thêm tất cả các file hiện có trong thư mục của ứng dụng. Bây giờ nếu bạn chạy câu lệnh git statusbạn sẽ chỉ thấy Git thông báo 1 file cần được thêm vào là package.json:\n\n```bash\n# On branch master\n#\n# Initial commit\n#\n# Untracked files:\n#   (use \"git add <file>...\" to include in what will be committed)\n#\n#   .gitignore\n#   package.json\n```\n\nTiếp theo chạy câu lệnh sau để thêm tất cả các file có trong thư mục dự án vào Git:\n\n```bash\n$ git add .\n```\n\nChạy git status một lần nữa để kiểm tra trạng thái của các file. Lúc này bạn sẽ thấy Git đánh dấu các file vừa được thêm vào bằng màu khác với trước đó:\n\n![alt text](https://i.imgur.com/GIdBjii.jpg \"github\")\n\nCuối cùng, chúng ta hãy tạo một commit đầu tiên sử dụng câu lệnh:\n\n```bash\n$ git commit -m 'First commit'\n```\n\nở đây, option -m được sử dụng để tạo message cho commit. Message này thường là nội dung tóm tắt mô tả xem commit thay đổi những gì trong source code. Vì đây là commit đầu tiên nên tôi chỉ đơn giản để là First commit.\n\n### Cấu Hình Git Repository\n\nKhi bạn tạo một ứng dụng sử dụng giao diện web trên trang Heroku, lúc này Heroku sẽ tạo cho bạn sẽ có một Git server repository (repo server). Repo server là một kho chứa code nhưng nó khác với local ở chỗ mọi lập trình viên trong dự án đều có thể để có thể đấy (push) source code lên trên đó hoặc kéo (pull) code của người khác về để cập nhật những thay đổi tạo ra bởi người khác. Để tìm thấy địa chỉ đường dẫn cho repository trên server Heroku này, vào trong trang quản lý app (dùng giao diện web trên Heroku) bạn click vào tab Settings. Ở đây bạn sẽ tìm thấy địa chỉ URL này, của tôi như sau:\n\n```bash\ngit@heroku.com:hoclaptrinh-expressjs-mongo.git\n```\n\nTiếp theo, để cấu hình URL này là server repo cho local repo, chạy câu lệnh sau:\n\n```bash\n$ git remote add origin git@heroku.com:hoclaptrinh-expressjs-mongo.git\n```\n\nĐể kiểm tra lại thông tin của repo server xem có chính xác hay chưa, chạy câu lệnh:\n\n```bash\n$ git remote -v\n```\nỞ đây option -v là viết tắt của từ verbose\n\n### Deploy Ứng Dụng\n\nĐể deploy ứng dụng lên Heroku, bạn cần cài đặt Heroku Toolbelt. Bạn có thể xem hướng dẫn về cách cài đặt Heroku Toolbelt ở bài viết Cài đặt và sử dụng Heroku Toolbelt.\n\nSau khi cài đặt xong Heroku Toolbelt bạn cần thêm ssh key để có thể đấy source code lên server. Để thêm ssh key chạy câu lệnh sau:\n\n```bash\n$ heroku keys:add\n```\n\nCuối cùng bạn có thể deploy source code lên Heroku bằng cách chạy câu lệnh:\n\n\n```bash\n$ git push -u origin master\n```\n\nKhi đấy souce code lần đầu tiên lên trên server bạn nên sử dụng option -uđể Git hiểu rằng repo server này sẽ theo dõi master branch của repo local. Trong các lần push source code tiếp theo bạn có thể làm đơn giản hơn bằng câu lệnh:\n\n```bash\n$ git push origin\n```\n\nLúc này Git hiểu rằng bạn muốn đẩy source code trong master local branch lên origin remote brach mà không cần phải thêm master vào trong câu lệnh.\nSau khi kết thúc việc push source code, Heroku sẽ tự động deploy ứng dụng cho bạn.\n\n<div style=\"text-align: right\">**Nguồn: Code Hub**</div>\n","slug":"deploy-voi-heroku","published":1,"updated":"2019-06-01T11:00:16.746Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwerksop0001a4su8d0g5w53","content":"<p>Heroku cung cấp dịch vụ máy chủ đám mây giúp dễ dàng trong việc deploy ứng dụng. Điều tuyệt vời ở Heroku là trang này bạn có thể sử dụng dịch vụ hoàn toàn miễn phí với các ứng dụng web không yêu cầu phải có tốc độ truy cập cao hay dung lượng lớn.</p>\n<p>Trong bài học này chúng ta sẽ</p>\n<ul>\n<li>Tạo một dự án trên heroku</li>\n<li>Cấu hình git server repository cho phía local</li>\n<li>Deploy ứng dụng</li>\n</ul>\n<h3 id=\"Tao-du-an-tren-heroku\"><a href=\"#Tao-du-an-tren-heroku\" class=\"headerlink\" title=\"Tạo dự án trên heroku\"></a>Tạo dự án trên heroku</h3><p>Để tạo dự án trên Heroku, bạn cần tạo một tài khoản (hoàn toàn miễn phí) sau đó kích hoạt và đăng nhập vào địa chỉ <a href=\"https://dashboard.heroku.com/\" target=\"_blank\" rel=\"noopener\">https://dashboard.heroku.com/</a>. Sau khi đăng nhập vào địa chỉ này, bạn sẽ thấy có một icon hình dấu cộng dùng để tạo dự án. Click vào icon này và chọn Create new app:</p>\n<p><img src=\"https://i.imgur.com/OiXd6go.png\" alt=\"alt text\" title=\"heroku deploy\"></p>\n<p>Trong mục App name chọn tên cho ứng dụng nếu bạn để trống Heroku sẽ chọn ngẫu nhiên một tên cho ứng dụng. Tiếp theo có 2 lựa chọn để chọn vùng cho server Heroku sẽ host ứng dụng là Mỹ và Châu Âu. Với các ứng dụng ở Việt Nam thì bạn nên chọn Europe để nâng cao tốc độ truy cập. Sau đó, bấm Create app.<br><img src=\"https://i.imgur.com/S1Up7Xu.png\" alt=\"alt text\" title=\"Create app heroku\"></p>\n<h3 id=\"Tao-Git-Repository-Tren-May-Local\"><a href=\"#Tao-Git-Repository-Tren-May-Local\" class=\"headerlink\" title=\"Tạo Git Repository Trên Máy Local\"></a>Tạo Git Repository Trên Máy Local</h3><p>Bây giờ trên máy tính local, chúng ta cần khởi tạo Git local repository (hay local repo). Local repo giống như một cái kho, nơi chứa source code mà bạn sẽ dùng để phát triển dụng. Trên terminal di chuyển tới thư mục ứng dụng ở máy tính bạn và chạy câu lệnh sau:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git init</span><br></pre></td></tr></table></figure>\n<p>Câu lệnh này dùng để khởi tạo một dự án Git ở trên máy tính local (hay còn gọi là local repo). Tiếp theo chạy câu lệnh sau để xem trạng thái (status) của các file trên local repo này:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br></pre></td></tr></table></figure>\n<p>Bạn sẽ thấy kết quả như sau:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Initial commit</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Untracked files:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to include in what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#   node_modules/</span></span><br><span class=\"line\"><span class=\"comment\">#   npm-debug.log</span></span><br><span class=\"line\"><span class=\"comment\">#   package.json</span></span><br><span class=\"line\">nothing added to commit but untracked files present (use <span class=\"string\">\"git add\"</span> to track)</span><br></pre></td></tr></table></figure></p>\n<p>Ở đây, Git nói với bạn có 2 file và 1 thư mục chưa được theo dõi (tracked) và để thêm chúng vào bạn cần chạy câu lệnh git add.</p>\n<p>Tuy nhiên, khi làm việc với ứng dụng Nodejs nói chung và Expressjs framework nói riêng, chúng ta không nên thêm file npm-debug.log và thư mục node_modules/ vào trong Git vì nội dung của 2 file này sẽ khác nhau phụ thuộc vào hệ điều hành mỗi lập trình viên sử dụng. Để Git không theo doi 2 file này, chúng ta tạo một file .gitignore với nội dung như sau:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/npm-debug.log</span><br><span class=\"line\">/node_modules/</span><br></pre></td></tr></table></figure>\n<p>Để thêm tất cả các file hiện có trong thư mục của ứng dụng. Bây giờ nếu bạn chạy câu lệnh git statusbạn sẽ chỉ thấy Git thông báo 1 file cần được thêm vào là package.json:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Initial commit</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Untracked files:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to include in what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#   .gitignore</span></span><br><span class=\"line\"><span class=\"comment\">#   package.json</span></span><br></pre></td></tr></table></figure>\n<p>Tiếp theo chạy câu lệnh sau để thêm tất cả các file có trong thư mục dự án vào Git:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br></pre></td></tr></table></figure>\n<p>Chạy git status một lần nữa để kiểm tra trạng thái của các file. Lúc này bạn sẽ thấy Git đánh dấu các file vừa được thêm vào bằng màu khác với trước đó:</p>\n<p><img src=\"https://i.imgur.com/GIdBjii.jpg\" alt=\"alt text\" title=\"github\"></p>\n<p>Cuối cùng, chúng ta hãy tạo một commit đầu tiên sử dụng câu lệnh:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m <span class=\"string\">'First commit'</span></span><br></pre></td></tr></table></figure>\n<p>ở đây, option -m được sử dụng để tạo message cho commit. Message này thường là nội dung tóm tắt mô tả xem commit thay đổi những gì trong source code. Vì đây là commit đầu tiên nên tôi chỉ đơn giản để là First commit.</p>\n<h3 id=\"Cau-Hinh-Git-Repository\"><a href=\"#Cau-Hinh-Git-Repository\" class=\"headerlink\" title=\"Cấu Hình Git Repository\"></a>Cấu Hình Git Repository</h3><p>Khi bạn tạo một ứng dụng sử dụng giao diện web trên trang Heroku, lúc này Heroku sẽ tạo cho bạn sẽ có một Git server repository (repo server). Repo server là một kho chứa code nhưng nó khác với local ở chỗ mọi lập trình viên trong dự án đều có thể để có thể đấy (push) source code lên trên đó hoặc kéo (pull) code của người khác về để cập nhật những thay đổi tạo ra bởi người khác. Để tìm thấy địa chỉ đường dẫn cho repository trên server Heroku này, vào trong trang quản lý app (dùng giao diện web trên Heroku) bạn click vào tab Settings. Ở đây bạn sẽ tìm thấy địa chỉ URL này, của tôi như sau:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git@heroku.com:hoclaptrinh-expressjs-mongo.git</span><br></pre></td></tr></table></figure>\n<p>Tiếp theo, để cấu hình URL này là server repo cho local repo, chạy câu lệnh sau:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote add origin git@heroku.com:hoclaptrinh-expressjs-mongo.git</span><br></pre></td></tr></table></figure>\n<p>Để kiểm tra lại thông tin của repo server xem có chính xác hay chưa, chạy câu lệnh:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote -v</span><br></pre></td></tr></table></figure>\n<p>Ở đây option -v là viết tắt của từ verbose</p>\n<h3 id=\"Deploy-Ung-Dung\"><a href=\"#Deploy-Ung-Dung\" class=\"headerlink\" title=\"Deploy Ứng Dụng\"></a>Deploy Ứng Dụng</h3><p>Để deploy ứng dụng lên Heroku, bạn cần cài đặt Heroku Toolbelt. Bạn có thể xem hướng dẫn về cách cài đặt Heroku Toolbelt ở bài viết Cài đặt và sử dụng Heroku Toolbelt.</p>\n<p>Sau khi cài đặt xong Heroku Toolbelt bạn cần thêm ssh key để có thể đấy source code lên server. Để thêm ssh key chạy câu lệnh sau:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ heroku keys:add</span><br></pre></td></tr></table></figure>\n<p>Cuối cùng bạn có thể deploy source code lên Heroku bằng cách chạy câu lệnh:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push -u origin master</span><br></pre></td></tr></table></figure>\n<p>Khi đấy souce code lần đầu tiên lên trên server bạn nên sử dụng option -uđể Git hiểu rằng repo server này sẽ theo dõi master branch của repo local. Trong các lần push source code tiếp theo bạn có thể làm đơn giản hơn bằng câu lệnh:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin</span><br></pre></td></tr></table></figure>\n<p>Lúc này Git hiểu rằng bạn muốn đẩy source code trong master local branch lên origin remote brach mà không cần phải thêm master vào trong câu lệnh.<br>Sau khi kết thúc việc push source code, Heroku sẽ tự động deploy ứng dụng cho bạn.</p>\n<div style=\"text-align: right\"><strong>Nguồn: Code Hub</strong></div>\n","site":{"data":{}},"excerpt":"Heroku cung cấp dịch vụ máy chủ đám mây giúp dễ dàng trong việc deploy ứng dụng. Điều tuyệt vời ở Heroku là trang này bạn có thể sử dụng dịch vụ hoàn toàn miễn phí với các ứng dụng web không yêu cầu phải có tốc độ truy cập cao hay dung lượng lớn.\n\nTrong bài học này chúng ta sẽ\n\n * Tạo một dự án trên","more":"<p>Heroku cung cấp dịch vụ máy chủ đám mây giúp dễ dàng trong việc deploy ứng dụng. Điều tuyệt vời ở Heroku là trang này bạn có thể sử dụng dịch vụ hoàn toàn miễn phí với các ứng dụng web không yêu cầu phải có tốc độ truy cập cao hay dung lượng lớn.</p>\n<p>Trong bài học này chúng ta sẽ</p>\n<ul>\n<li>Tạo một dự án trên heroku</li>\n<li>Cấu hình git server repository cho phía local</li>\n<li>Deploy ứng dụng</li>\n</ul>\n<h3 id=\"Tao-du-an-tren-heroku\"><a href=\"#Tao-du-an-tren-heroku\" class=\"headerlink\" title=\"Tạo dự án trên heroku\"></a>Tạo dự án trên heroku</h3><p>Để tạo dự án trên Heroku, bạn cần tạo một tài khoản (hoàn toàn miễn phí) sau đó kích hoạt và đăng nhập vào địa chỉ <a href=\"https://dashboard.heroku.com/\" target=\"_blank\" rel=\"noopener\">https://dashboard.heroku.com/</a>. Sau khi đăng nhập vào địa chỉ này, bạn sẽ thấy có một icon hình dấu cộng dùng để tạo dự án. Click vào icon này và chọn Create new app:</p>\n<p><img src=\"https://i.imgur.com/OiXd6go.png\" alt=\"alt text\" title=\"heroku deploy\"></p>\n<p>Trong mục App name chọn tên cho ứng dụng nếu bạn để trống Heroku sẽ chọn ngẫu nhiên một tên cho ứng dụng. Tiếp theo có 2 lựa chọn để chọn vùng cho server Heroku sẽ host ứng dụng là Mỹ và Châu Âu. Với các ứng dụng ở Việt Nam thì bạn nên chọn Europe để nâng cao tốc độ truy cập. Sau đó, bấm Create app.<br><img src=\"https://i.imgur.com/S1Up7Xu.png\" alt=\"alt text\" title=\"Create app heroku\"></p>\n<h3 id=\"Tao-Git-Repository-Tren-May-Local\"><a href=\"#Tao-Git-Repository-Tren-May-Local\" class=\"headerlink\" title=\"Tạo Git Repository Trên Máy Local\"></a>Tạo Git Repository Trên Máy Local</h3><p>Bây giờ trên máy tính local, chúng ta cần khởi tạo Git local repository (hay local repo). Local repo giống như một cái kho, nơi chứa source code mà bạn sẽ dùng để phát triển dụng. Trên terminal di chuyển tới thư mục ứng dụng ở máy tính bạn và chạy câu lệnh sau:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git init</span><br></pre></td></tr></table></figure>\n<p>Câu lệnh này dùng để khởi tạo một dự án Git ở trên máy tính local (hay còn gọi là local repo). Tiếp theo chạy câu lệnh sau để xem trạng thái (status) của các file trên local repo này:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br></pre></td></tr></table></figure>\n<p>Bạn sẽ thấy kết quả như sau:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Initial commit</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Untracked files:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to include in what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#   node_modules/</span></span><br><span class=\"line\"><span class=\"comment\">#   npm-debug.log</span></span><br><span class=\"line\"><span class=\"comment\">#   package.json</span></span><br><span class=\"line\">nothing added to commit but untracked files present (use <span class=\"string\">\"git add\"</span> to track)</span><br></pre></td></tr></table></figure></p>\n<p>Ở đây, Git nói với bạn có 2 file và 1 thư mục chưa được theo dõi (tracked) và để thêm chúng vào bạn cần chạy câu lệnh git add.</p>\n<p>Tuy nhiên, khi làm việc với ứng dụng Nodejs nói chung và Expressjs framework nói riêng, chúng ta không nên thêm file npm-debug.log và thư mục node_modules/ vào trong Git vì nội dung của 2 file này sẽ khác nhau phụ thuộc vào hệ điều hành mỗi lập trình viên sử dụng. Để Git không theo doi 2 file này, chúng ta tạo một file .gitignore với nội dung như sau:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/npm-debug.log</span><br><span class=\"line\">/node_modules/</span><br></pre></td></tr></table></figure>\n<p>Để thêm tất cả các file hiện có trong thư mục của ứng dụng. Bây giờ nếu bạn chạy câu lệnh git statusbạn sẽ chỉ thấy Git thông báo 1 file cần được thêm vào là package.json:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Initial commit</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Untracked files:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to include in what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#   .gitignore</span></span><br><span class=\"line\"><span class=\"comment\">#   package.json</span></span><br></pre></td></tr></table></figure>\n<p>Tiếp theo chạy câu lệnh sau để thêm tất cả các file có trong thư mục dự án vào Git:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br></pre></td></tr></table></figure>\n<p>Chạy git status một lần nữa để kiểm tra trạng thái của các file. Lúc này bạn sẽ thấy Git đánh dấu các file vừa được thêm vào bằng màu khác với trước đó:</p>\n<p><img src=\"https://i.imgur.com/GIdBjii.jpg\" alt=\"alt text\" title=\"github\"></p>\n<p>Cuối cùng, chúng ta hãy tạo một commit đầu tiên sử dụng câu lệnh:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m <span class=\"string\">'First commit'</span></span><br></pre></td></tr></table></figure>\n<p>ở đây, option -m được sử dụng để tạo message cho commit. Message này thường là nội dung tóm tắt mô tả xem commit thay đổi những gì trong source code. Vì đây là commit đầu tiên nên tôi chỉ đơn giản để là First commit.</p>\n<h3 id=\"Cau-Hinh-Git-Repository\"><a href=\"#Cau-Hinh-Git-Repository\" class=\"headerlink\" title=\"Cấu Hình Git Repository\"></a>Cấu Hình Git Repository</h3><p>Khi bạn tạo một ứng dụng sử dụng giao diện web trên trang Heroku, lúc này Heroku sẽ tạo cho bạn sẽ có một Git server repository (repo server). Repo server là một kho chứa code nhưng nó khác với local ở chỗ mọi lập trình viên trong dự án đều có thể để có thể đấy (push) source code lên trên đó hoặc kéo (pull) code của người khác về để cập nhật những thay đổi tạo ra bởi người khác. Để tìm thấy địa chỉ đường dẫn cho repository trên server Heroku này, vào trong trang quản lý app (dùng giao diện web trên Heroku) bạn click vào tab Settings. Ở đây bạn sẽ tìm thấy địa chỉ URL này, của tôi như sau:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git@heroku.com:hoclaptrinh-expressjs-mongo.git</span><br></pre></td></tr></table></figure>\n<p>Tiếp theo, để cấu hình URL này là server repo cho local repo, chạy câu lệnh sau:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote add origin git@heroku.com:hoclaptrinh-expressjs-mongo.git</span><br></pre></td></tr></table></figure>\n<p>Để kiểm tra lại thông tin của repo server xem có chính xác hay chưa, chạy câu lệnh:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote -v</span><br></pre></td></tr></table></figure>\n<p>Ở đây option -v là viết tắt của từ verbose</p>\n<h3 id=\"Deploy-Ung-Dung\"><a href=\"#Deploy-Ung-Dung\" class=\"headerlink\" title=\"Deploy Ứng Dụng\"></a>Deploy Ứng Dụng</h3><p>Để deploy ứng dụng lên Heroku, bạn cần cài đặt Heroku Toolbelt. Bạn có thể xem hướng dẫn về cách cài đặt Heroku Toolbelt ở bài viết Cài đặt và sử dụng Heroku Toolbelt.</p>\n<p>Sau khi cài đặt xong Heroku Toolbelt bạn cần thêm ssh key để có thể đấy source code lên server. Để thêm ssh key chạy câu lệnh sau:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ heroku keys:add</span><br></pre></td></tr></table></figure>\n<p>Cuối cùng bạn có thể deploy source code lên Heroku bằng cách chạy câu lệnh:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push -u origin master</span><br></pre></td></tr></table></figure>\n<p>Khi đấy souce code lần đầu tiên lên trên server bạn nên sử dụng option -uđể Git hiểu rằng repo server này sẽ theo dõi master branch của repo local. Trong các lần push source code tiếp theo bạn có thể làm đơn giản hơn bằng câu lệnh:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin</span><br></pre></td></tr></table></figure>\n<p>Lúc này Git hiểu rằng bạn muốn đẩy source code trong master local branch lên origin remote brach mà không cần phải thêm master vào trong câu lệnh.<br>Sau khi kết thúc việc push source code, Heroku sẽ tự động deploy ứng dụng cho bạn.</p>\n<div style=\"text-align: right\"><strong>Nguồn: Code Hub</strong></div>\n"},{"title":"Cùng tìm hiểu về Higher Order Component trong ReactJs","date":"2019-06-02T09:49:36.000Z","_content":"\n**Higher-order component** (HOC) là một kỹ thuật nâng cao trong React được sử dụng trong việc sử dụng lại các component. HOCs không là một phần trong React API. Một cách cụ thể, **một higher-order component là một hàm và nó nhận đối số là một component và trả về một component mới.** Higher-order component là một pattern tuyệt với và nó được chứng minh trong nhiều thư viện React ví dụ như Redux (thư viện được sử dụng để quản lý state) hay React-DnD (là một thư viện về drag and drop, nó khá khó hiểu cho người mới bắt đầu)...\n\n\n`const EnhancedComponent = higherOrderComponent(WrappedComponent);`\n\nTrong bài viết này, chúng ta sẽ thảo luận tại sao higher-order components thì thực sự hữu ích và cách để sử dụng nó.\n\n### Sử dụng HOCs cho Cross-Cutting Concerns\n\n**Cross-cutting concerns** hiểu nôm na là những xử lý phụ được xảy ra trước khi xử lý chính được thực hiện. Thực ra ta có thể sử dụng mixins để có thể áp dụng cross-cutting concerns, nhưng mixins sẽ tạo ra nhiều vấn đề hơn là những gì nó làm được.\n\nComponents là đơn vị cơ bản nhất trong React mà ta có thể sử dụng lại. Tuy nhiên, ta sẽ tìm một số các phần mà không phù hợp với việc ta đang muốn sử dụng và ta sẽ phải implement component đó theo mong muốn của ta.\n\nVí dụ, ta có component CommentList nhận thông tin từ một data source để render ra một danh sách các comments:\n\n~~~~\nclass CommentList extends React.Component {\nconstructor() {\n  super();\n  this.state = {\n    // \"DataSource\" is some global data source\n    comments: DataSource.getComments()\n  };\n}\n\ncomponentDidMount() {\n  // Subscribe to changes\n  DataSource.addChangeListener(this.handleChange);\n}\n\ncomponentWillUnmount() {\n  // Clean up listener\n  DataSource.removeChangeListener(this.handleChange);\n}\n\nhandleChange = () => {\n  // Update component state whenever the data source changes\n  this.setState({\n    comments: DataSource.getComments()\n  });\n}\n\nrender() {\n  return (\n    <div>\n      {this.state.comments.map((comment) => (\n        <Comment comment={comment} key={comment.id} />\n      ))}\n    </div>\n  );\n}\n}\n~~~~\n\nSau đó, ta lại viết một component sử dụng cho việc nhận dữ liệu là các bài viết để hiện thị danh sách, với một pattern tương tự:\n\n~~~~\nclass BlogPost extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      blogPost: DataSource.getBlogPost(props.id)\n    };\n  }\n\n  componentDidMount() {\n    DataSource.addChangeListener(this.handleChange);\n  }\n\n  componentWillUnmount() {\n    DataSource.removeChangeListener(this.handleChange);\n  }\n\n  handleChange = () => {\n    this.setState({\n      blogPost: DataSource.getBlogPost(this.props.id)\n    });\n  }\n\n  render() {\n    return <TextBlock text={this.state.blogPost} />;\n  }\n}\n~~~~\n\nSau khi đọc xong 2 component trên, ta có thể thấy rằng 2 component trên đang thực hiện một quy trình tương tự:\n\n  + Ở componentDidMount, truyền hàm khi thực hiện thay đổi handleChange cho DataSource.\n  + Trong hàm handleChange thực hiện việc setState khi dữ liệu thay đổi.\n  + Ở componentWillUnmount, thực hiện bỏ hàm handleChange.\n\nTa có thể tưởng tượng với một ứng dụng lớn, việc lặp lại này được thực hiện liên tục. Do vậy ta sẽ muốn một cách trừu tượng hóa để cho phép ta có thể định nghĩa logic ở một nơi và chia sẻ chúng cho nhiều compoment khác. Và chính điều này làm cho higher-order components nổi trội hơn cả.\n\nChúng ta có thể viết một hàm mà tạo ra các component như là CommentList và BlogPost nhận thông tin từ DataSource. Nó sẽ nhận đối số là một component con:\n\n~~~~\nconst CommentListWithSubscription = withSubscription(\n  CommentList,\n  (DataSource) => DataSource.getComments()\n);\n\nconst BlogPostWithSubscription = withSubscription(\n  BlogPost,\n  (DataSource, props) => DataSource.getBlogPost(props.id)\n});\n~~~~\n\nHàm này nhận 2 đối số, một là component được gói vào, hai là hàm lấy dữ liệu mà ta muốn.\n\nKhi CommentListWithSubscription và BlogPostWithSubscription được render thì CommentList và BlogPost sẽ nhận dữ liệu từ prop:\n\n~~~~\nfunction withSubscription(WrappedComponent, selectData) {\n  return class extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        data: selectData(DataSource, props)\n      };\n    }\n\n    componentDidMount() {\n      DataSource.addChangeListener(this.handleChange);\n    }\n\n    componentWillUnmount() {\n      DataSource.removeChangeListener(this.handleChange);\n    }\n\n    handleChange = () => {\n      this.setState({\n        data: selectData(DataSource, this.props)\n      });\n    }\n\n    render() {\n      return <WrappedComponent data={this.state.data} {...this.props} />;\n    }\n  };\n}\n~~~~\n\nNote that an HOC doesn't modify the input component, nor does it use inheritance to copy its behavior. Rather, an HOC composes the original component by wrapping it in a container component. An HOC is a pure function with zero side-effects.\n\nAnd that's it! The wrapped component receives all the props of the container, along with a new prop, data, which it uses to render its output. The HOC isn't concerned with how or why the data is used, and the wrapped component isn't concerned with where the data came from.\n\nCần nhớ một điều là HOC không chỉnh sửa, làm khác đi component đầu vào mà nó chỉ kế thừa các hành vi của component đó.\n\nComponent được gói vào nhận tất các props của container, với props nó có thể sử dụng để render ra nội dung mà mình mong muốn. HOC không liên quan đến việc dữ liệu được sử dụng như thế nào, từ đâu, và component được gói vào cũng không liên quan đến dữ liệu được truyền từ đâu.\n\n\n### Đừng thay đổi component gốc, hãy soạn lại component\n\nVí dụ ta có 1 HOC chỉ in ra props và trả về chính component đầu vào:\n\n~~~~\nfunction logProps(InputComponent) {\n  InputComponent.prototype.componentWillReceiveProps(nextProps) {\n    console.log('Current props: ', this.props);\n    console.log('Next props: ', nextProps);\n  }\n  return InputComponent;\n}\n\nconst EnhancedComponent = logProps(InputComponent);\n~~~~\n\nCó một số vấn đề ở đây. Thứ nhất InputComponent không thể sử dụng lại một cách riêng biệt với EnhancedComponent. Quan trọng hơn nữa, nếu ta muốn sử dụng một HOC khác có EnhancedComponent thì cũng sẽ thay đổi hàm componentWillReceiveProps của HOC đầu tiên, vì vậy ta cần phải biết ta đang implement cái gì để tránh conflict với những HOC khác.\n\nThay vì thay đổi, ta nên sử dụng composition bằng việc gói component đầu vào bên trong một container:\n\n~~~~\nfunction logProps(WrappedComponent) {\n  return class extends React.Component {\n    componentWillReceiveProps(nextProps) {\n      console.log('Current props: ', this.props);\n      console.log('Next props: ', nextProps);\n    }\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n}\n~~~~\n\n\nHOC này có chức năng tương tự như HOC ở bên trên (đã bị thay đổi) trong khi tránh được việc thay đổi, nguy cơ tiềm ẩn. This HOC has the same functionality as the mutating version while avoiding the potential for clashes. It works equally well with class and functional components. And because it's a pure function, it's composable with other HOCs, or even with itself.\n\nYou may have noticed similarities between HOCs and a pattern called container components. Container components are part of a strategy of separating responsibility between high-level and low-level concerns. Containers manage things like subscriptions and state, and pass props to components that handle things like rendering UI. HOCs use containers as part of their implementation. You can think of HOCs as parameterized container component definitions.\n\n<div style=\"text-align: right\">**Nguồn: Viblo**</div>\n","source":"_posts/tim-hieu-Higher-Order-Component-trong-React.md","raw":"---\ntitle: Cùng tìm hiểu về Higher Order Component trong ReactJs\ndate: 2019-06-02 16:49:36\ntags:\n---\n\n**Higher-order component** (HOC) là một kỹ thuật nâng cao trong React được sử dụng trong việc sử dụng lại các component. HOCs không là một phần trong React API. Một cách cụ thể, **một higher-order component là một hàm và nó nhận đối số là một component và trả về một component mới.** Higher-order component là một pattern tuyệt với và nó được chứng minh trong nhiều thư viện React ví dụ như Redux (thư viện được sử dụng để quản lý state) hay React-DnD (là một thư viện về drag and drop, nó khá khó hiểu cho người mới bắt đầu)...\n\n\n`const EnhancedComponent = higherOrderComponent(WrappedComponent);`\n\nTrong bài viết này, chúng ta sẽ thảo luận tại sao higher-order components thì thực sự hữu ích và cách để sử dụng nó.\n\n### Sử dụng HOCs cho Cross-Cutting Concerns\n\n**Cross-cutting concerns** hiểu nôm na là những xử lý phụ được xảy ra trước khi xử lý chính được thực hiện. Thực ra ta có thể sử dụng mixins để có thể áp dụng cross-cutting concerns, nhưng mixins sẽ tạo ra nhiều vấn đề hơn là những gì nó làm được.\n\nComponents là đơn vị cơ bản nhất trong React mà ta có thể sử dụng lại. Tuy nhiên, ta sẽ tìm một số các phần mà không phù hợp với việc ta đang muốn sử dụng và ta sẽ phải implement component đó theo mong muốn của ta.\n\nVí dụ, ta có component CommentList nhận thông tin từ một data source để render ra một danh sách các comments:\n\n~~~~\nclass CommentList extends React.Component {\nconstructor() {\n  super();\n  this.state = {\n    // \"DataSource\" is some global data source\n    comments: DataSource.getComments()\n  };\n}\n\ncomponentDidMount() {\n  // Subscribe to changes\n  DataSource.addChangeListener(this.handleChange);\n}\n\ncomponentWillUnmount() {\n  // Clean up listener\n  DataSource.removeChangeListener(this.handleChange);\n}\n\nhandleChange = () => {\n  // Update component state whenever the data source changes\n  this.setState({\n    comments: DataSource.getComments()\n  });\n}\n\nrender() {\n  return (\n    <div>\n      {this.state.comments.map((comment) => (\n        <Comment comment={comment} key={comment.id} />\n      ))}\n    </div>\n  );\n}\n}\n~~~~\n\nSau đó, ta lại viết một component sử dụng cho việc nhận dữ liệu là các bài viết để hiện thị danh sách, với một pattern tương tự:\n\n~~~~\nclass BlogPost extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      blogPost: DataSource.getBlogPost(props.id)\n    };\n  }\n\n  componentDidMount() {\n    DataSource.addChangeListener(this.handleChange);\n  }\n\n  componentWillUnmount() {\n    DataSource.removeChangeListener(this.handleChange);\n  }\n\n  handleChange = () => {\n    this.setState({\n      blogPost: DataSource.getBlogPost(this.props.id)\n    });\n  }\n\n  render() {\n    return <TextBlock text={this.state.blogPost} />;\n  }\n}\n~~~~\n\nSau khi đọc xong 2 component trên, ta có thể thấy rằng 2 component trên đang thực hiện một quy trình tương tự:\n\n  + Ở componentDidMount, truyền hàm khi thực hiện thay đổi handleChange cho DataSource.\n  + Trong hàm handleChange thực hiện việc setState khi dữ liệu thay đổi.\n  + Ở componentWillUnmount, thực hiện bỏ hàm handleChange.\n\nTa có thể tưởng tượng với một ứng dụng lớn, việc lặp lại này được thực hiện liên tục. Do vậy ta sẽ muốn một cách trừu tượng hóa để cho phép ta có thể định nghĩa logic ở một nơi và chia sẻ chúng cho nhiều compoment khác. Và chính điều này làm cho higher-order components nổi trội hơn cả.\n\nChúng ta có thể viết một hàm mà tạo ra các component như là CommentList và BlogPost nhận thông tin từ DataSource. Nó sẽ nhận đối số là một component con:\n\n~~~~\nconst CommentListWithSubscription = withSubscription(\n  CommentList,\n  (DataSource) => DataSource.getComments()\n);\n\nconst BlogPostWithSubscription = withSubscription(\n  BlogPost,\n  (DataSource, props) => DataSource.getBlogPost(props.id)\n});\n~~~~\n\nHàm này nhận 2 đối số, một là component được gói vào, hai là hàm lấy dữ liệu mà ta muốn.\n\nKhi CommentListWithSubscription và BlogPostWithSubscription được render thì CommentList và BlogPost sẽ nhận dữ liệu từ prop:\n\n~~~~\nfunction withSubscription(WrappedComponent, selectData) {\n  return class extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        data: selectData(DataSource, props)\n      };\n    }\n\n    componentDidMount() {\n      DataSource.addChangeListener(this.handleChange);\n    }\n\n    componentWillUnmount() {\n      DataSource.removeChangeListener(this.handleChange);\n    }\n\n    handleChange = () => {\n      this.setState({\n        data: selectData(DataSource, this.props)\n      });\n    }\n\n    render() {\n      return <WrappedComponent data={this.state.data} {...this.props} />;\n    }\n  };\n}\n~~~~\n\nNote that an HOC doesn't modify the input component, nor does it use inheritance to copy its behavior. Rather, an HOC composes the original component by wrapping it in a container component. An HOC is a pure function with zero side-effects.\n\nAnd that's it! The wrapped component receives all the props of the container, along with a new prop, data, which it uses to render its output. The HOC isn't concerned with how or why the data is used, and the wrapped component isn't concerned with where the data came from.\n\nCần nhớ một điều là HOC không chỉnh sửa, làm khác đi component đầu vào mà nó chỉ kế thừa các hành vi của component đó.\n\nComponent được gói vào nhận tất các props của container, với props nó có thể sử dụng để render ra nội dung mà mình mong muốn. HOC không liên quan đến việc dữ liệu được sử dụng như thế nào, từ đâu, và component được gói vào cũng không liên quan đến dữ liệu được truyền từ đâu.\n\n\n### Đừng thay đổi component gốc, hãy soạn lại component\n\nVí dụ ta có 1 HOC chỉ in ra props và trả về chính component đầu vào:\n\n~~~~\nfunction logProps(InputComponent) {\n  InputComponent.prototype.componentWillReceiveProps(nextProps) {\n    console.log('Current props: ', this.props);\n    console.log('Next props: ', nextProps);\n  }\n  return InputComponent;\n}\n\nconst EnhancedComponent = logProps(InputComponent);\n~~~~\n\nCó một số vấn đề ở đây. Thứ nhất InputComponent không thể sử dụng lại một cách riêng biệt với EnhancedComponent. Quan trọng hơn nữa, nếu ta muốn sử dụng một HOC khác có EnhancedComponent thì cũng sẽ thay đổi hàm componentWillReceiveProps của HOC đầu tiên, vì vậy ta cần phải biết ta đang implement cái gì để tránh conflict với những HOC khác.\n\nThay vì thay đổi, ta nên sử dụng composition bằng việc gói component đầu vào bên trong một container:\n\n~~~~\nfunction logProps(WrappedComponent) {\n  return class extends React.Component {\n    componentWillReceiveProps(nextProps) {\n      console.log('Current props: ', this.props);\n      console.log('Next props: ', nextProps);\n    }\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n}\n~~~~\n\n\nHOC này có chức năng tương tự như HOC ở bên trên (đã bị thay đổi) trong khi tránh được việc thay đổi, nguy cơ tiềm ẩn. This HOC has the same functionality as the mutating version while avoiding the potential for clashes. It works equally well with class and functional components. And because it's a pure function, it's composable with other HOCs, or even with itself.\n\nYou may have noticed similarities between HOCs and a pattern called container components. Container components are part of a strategy of separating responsibility between high-level and low-level concerns. Containers manage things like subscriptions and state, and pass props to components that handle things like rendering UI. HOCs use containers as part of their implementation. You can think of HOCs as parameterized container component definitions.\n\n<div style=\"text-align: right\">**Nguồn: Viblo**</div>\n","slug":"tim-hieu-Higher-Order-Component-trong-React","published":1,"updated":"2019-06-02T09:59:39.538Z","_id":"cjwerlkh40004a4su5eyblsj4","comments":1,"layout":"post","photos":[],"link":"","content":"<p><strong>Higher-order component</strong> (HOC) là một kỹ thuật nâng cao trong React được sử dụng trong việc sử dụng lại các component. HOCs không là một phần trong React API. Một cách cụ thể, <strong>một higher-order component là một hàm và nó nhận đối số là một component và trả về một component mới.</strong> Higher-order component là một pattern tuyệt với và nó được chứng minh trong nhiều thư viện React ví dụ như Redux (thư viện được sử dụng để quản lý state) hay React-DnD (là một thư viện về drag and drop, nó khá khó hiểu cho người mới bắt đầu)…</p>\n<p><code>const EnhancedComponent = higherOrderComponent(WrappedComponent);</code></p>\n<p>Trong bài viết này, chúng ta sẽ thảo luận tại sao higher-order components thì thực sự hữu ích và cách để sử dụng nó.</p>\n<h3 id=\"Su-dung-HOCs-cho-Cross-Cutting-Concerns\"><a href=\"#Su-dung-HOCs-cho-Cross-Cutting-Concerns\" class=\"headerlink\" title=\"Sử dụng HOCs cho Cross-Cutting Concerns\"></a>Sử dụng HOCs cho Cross-Cutting Concerns</h3><p><strong>Cross-cutting concerns</strong> hiểu nôm na là những xử lý phụ được xảy ra trước khi xử lý chính được thực hiện. Thực ra ta có thể sử dụng mixins để có thể áp dụng cross-cutting concerns, nhưng mixins sẽ tạo ra nhiều vấn đề hơn là những gì nó làm được.</p>\n<p>Components là đơn vị cơ bản nhất trong React mà ta có thể sử dụng lại. Tuy nhiên, ta sẽ tìm một số các phần mà không phù hợp với việc ta đang muốn sử dụng và ta sẽ phải implement component đó theo mong muốn của ta.</p>\n<p>Ví dụ, ta có component CommentList nhận thông tin từ một data source để render ra một danh sách các comments:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class CommentList extends React.Component &#123;</span><br><span class=\"line\">constructor() &#123;</span><br><span class=\"line\">  super();</span><br><span class=\"line\">  this.state = &#123;</span><br><span class=\"line\">    // &quot;DataSource&quot; is some global data source</span><br><span class=\"line\">    comments: DataSource.getComments()</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">componentDidMount() &#123;</span><br><span class=\"line\">  // Subscribe to changes</span><br><span class=\"line\">  DataSource.addChangeListener(this.handleChange);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">componentWillUnmount() &#123;</span><br><span class=\"line\">  // Clean up listener</span><br><span class=\"line\">  DataSource.removeChangeListener(this.handleChange);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">handleChange = () =&gt; &#123;</span><br><span class=\"line\">  // Update component state whenever the data source changes</span><br><span class=\"line\">  this.setState(&#123;</span><br><span class=\"line\">    comments: DataSource.getComments()</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">render() &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &#123;this.state.comments.map((comment) =&gt; (</span><br><span class=\"line\">        &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt;</span><br><span class=\"line\">      ))&#125;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Sau đó, ta lại viết một component sử dụng cho việc nhận dữ liệu là các bài viết để hiện thị danh sách, với một pattern tương tự:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class BlogPost extends React.Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state = &#123;</span><br><span class=\"line\">      blogPost: DataSource.getBlogPost(props.id)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    DataSource.addChangeListener(this.handleChange);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentWillUnmount() &#123;</span><br><span class=\"line\">    DataSource.removeChangeListener(this.handleChange);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleChange = () =&gt; &#123;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      blogPost: DataSource.getBlogPost(this.props.id)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return &lt;TextBlock text=&#123;this.state.blogPost&#125; /&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Sau khi đọc xong 2 component trên, ta có thể thấy rằng 2 component trên đang thực hiện một quy trình tương tự:</p>\n<ul>\n<li>Ở componentDidMount, truyền hàm khi thực hiện thay đổi handleChange cho DataSource.</li>\n<li>Trong hàm handleChange thực hiện việc setState khi dữ liệu thay đổi.</li>\n<li>Ở componentWillUnmount, thực hiện bỏ hàm handleChange.</li>\n</ul>\n<p>Ta có thể tưởng tượng với một ứng dụng lớn, việc lặp lại này được thực hiện liên tục. Do vậy ta sẽ muốn một cách trừu tượng hóa để cho phép ta có thể định nghĩa logic ở một nơi và chia sẻ chúng cho nhiều compoment khác. Và chính điều này làm cho higher-order components nổi trội hơn cả.</p>\n<p>Chúng ta có thể viết một hàm mà tạo ra các component như là CommentList và BlogPost nhận thông tin từ DataSource. Nó sẽ nhận đối số là một component con:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const CommentListWithSubscription = withSubscription(</span><br><span class=\"line\">  CommentList,</span><br><span class=\"line\">  (DataSource) =&gt; DataSource.getComments()</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">const BlogPostWithSubscription = withSubscription(</span><br><span class=\"line\">  BlogPost,</span><br><span class=\"line\">  (DataSource, props) =&gt; DataSource.getBlogPost(props.id)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Hàm này nhận 2 đối số, một là component được gói vào, hai là hàm lấy dữ liệu mà ta muốn.</p>\n<p>Khi CommentListWithSubscription và BlogPostWithSubscription được render thì CommentList và BlogPost sẽ nhận dữ liệu từ prop:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function withSubscription(WrappedComponent, selectData) &#123;</span><br><span class=\"line\">  return class extends React.Component &#123;</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">      super(props);</span><br><span class=\"line\">      this.state = &#123;</span><br><span class=\"line\">        data: selectData(DataSource, props)</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">      DataSource.addChangeListener(this.handleChange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentWillUnmount() &#123;</span><br><span class=\"line\">      DataSource.removeChangeListener(this.handleChange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleChange = () =&gt; &#123;</span><br><span class=\"line\">      this.setState(&#123;</span><br><span class=\"line\">        data: selectData(DataSource, this.props)</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      return &lt;WrappedComponent data=&#123;this.state.data&#125; &#123;...this.props&#125; /&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Note that an HOC doesn’t modify the input component, nor does it use inheritance to copy its behavior. Rather, an HOC composes the original component by wrapping it in a container component. An HOC is a pure function with zero side-effects.</p>\n<p>And that’s it! The wrapped component receives all the props of the container, along with a new prop, data, which it uses to render its output. The HOC isn’t concerned with how or why the data is used, and the wrapped component isn’t concerned with where the data came from.</p>\n<p>Cần nhớ một điều là HOC không chỉnh sửa, làm khác đi component đầu vào mà nó chỉ kế thừa các hành vi của component đó.</p>\n<p>Component được gói vào nhận tất các props của container, với props nó có thể sử dụng để render ra nội dung mà mình mong muốn. HOC không liên quan đến việc dữ liệu được sử dụng như thế nào, từ đâu, và component được gói vào cũng không liên quan đến dữ liệu được truyền từ đâu.</p>\n<h3 id=\"Dung-thay-doi-component-goc-hay-soan-lai-component\"><a href=\"#Dung-thay-doi-component-goc-hay-soan-lai-component\" class=\"headerlink\" title=\"Đừng thay đổi component gốc, hãy soạn lại component\"></a>Đừng thay đổi component gốc, hãy soạn lại component</h3><p>Ví dụ ta có 1 HOC chỉ in ra props và trả về chính component đầu vào:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function logProps(InputComponent) &#123;</span><br><span class=\"line\">  InputComponent.prototype.componentWillReceiveProps(nextProps) &#123;</span><br><span class=\"line\">    console.log(&apos;Current props: &apos;, this.props);</span><br><span class=\"line\">    console.log(&apos;Next props: &apos;, nextProps);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return InputComponent;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const EnhancedComponent = logProps(InputComponent);</span><br></pre></td></tr></table></figure>\n<p>Có một số vấn đề ở đây. Thứ nhất InputComponent không thể sử dụng lại một cách riêng biệt với EnhancedComponent. Quan trọng hơn nữa, nếu ta muốn sử dụng một HOC khác có EnhancedComponent thì cũng sẽ thay đổi hàm componentWillReceiveProps của HOC đầu tiên, vì vậy ta cần phải biết ta đang implement cái gì để tránh conflict với những HOC khác.</p>\n<p>Thay vì thay đổi, ta nên sử dụng composition bằng việc gói component đầu vào bên trong một container:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function logProps(WrappedComponent) &#123;</span><br><span class=\"line\">  return class extends React.Component &#123;</span><br><span class=\"line\">    componentWillReceiveProps(nextProps) &#123;</span><br><span class=\"line\">      console.log(&apos;Current props: &apos;, this.props);</span><br><span class=\"line\">      console.log(&apos;Next props: &apos;, nextProps);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      return &lt;WrappedComponent &#123;...this.props&#125; /&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>HOC này có chức năng tương tự như HOC ở bên trên (đã bị thay đổi) trong khi tránh được việc thay đổi, nguy cơ tiềm ẩn. This HOC has the same functionality as the mutating version while avoiding the potential for clashes. It works equally well with class and functional components. And because it’s a pure function, it’s composable with other HOCs, or even with itself.</p>\n<p>You may have noticed similarities between HOCs and a pattern called container components. Container components are part of a strategy of separating responsibility between high-level and low-level concerns. Containers manage things like subscriptions and state, and pass props to components that handle things like rendering UI. HOCs use containers as part of their implementation. You can think of HOCs as parameterized container component definitions.</p>\n<div style=\"text-align: right\"><strong>Nguồn: Viblo</strong></div>\n","site":{"data":{}},"excerpt":"Higher-order component (HOC) là một kỹ thuật nâng cao trong React được sử dụng trong việc sử dụng lại các component. HOCs không là một phần trong React API. Một cách cụ thể, một higher-order component là một hàm và nó nhận đối số là một component và trả về một component mới. Higher-order component l","more":"<p><strong>Higher-order component</strong> (HOC) là một kỹ thuật nâng cao trong React được sử dụng trong việc sử dụng lại các component. HOCs không là một phần trong React API. Một cách cụ thể, <strong>một higher-order component là một hàm và nó nhận đối số là một component và trả về một component mới.</strong> Higher-order component là một pattern tuyệt với và nó được chứng minh trong nhiều thư viện React ví dụ như Redux (thư viện được sử dụng để quản lý state) hay React-DnD (là một thư viện về drag and drop, nó khá khó hiểu cho người mới bắt đầu)…</p>\n<p><code>const EnhancedComponent = higherOrderComponent(WrappedComponent);</code></p>\n<p>Trong bài viết này, chúng ta sẽ thảo luận tại sao higher-order components thì thực sự hữu ích và cách để sử dụng nó.</p>\n<h3 id=\"Su-dung-HOCs-cho-Cross-Cutting-Concerns\"><a href=\"#Su-dung-HOCs-cho-Cross-Cutting-Concerns\" class=\"headerlink\" title=\"Sử dụng HOCs cho Cross-Cutting Concerns\"></a>Sử dụng HOCs cho Cross-Cutting Concerns</h3><p><strong>Cross-cutting concerns</strong> hiểu nôm na là những xử lý phụ được xảy ra trước khi xử lý chính được thực hiện. Thực ra ta có thể sử dụng mixins để có thể áp dụng cross-cutting concerns, nhưng mixins sẽ tạo ra nhiều vấn đề hơn là những gì nó làm được.</p>\n<p>Components là đơn vị cơ bản nhất trong React mà ta có thể sử dụng lại. Tuy nhiên, ta sẽ tìm một số các phần mà không phù hợp với việc ta đang muốn sử dụng và ta sẽ phải implement component đó theo mong muốn của ta.</p>\n<p>Ví dụ, ta có component CommentList nhận thông tin từ một data source để render ra một danh sách các comments:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class CommentList extends React.Component &#123;</span><br><span class=\"line\">constructor() &#123;</span><br><span class=\"line\">  super();</span><br><span class=\"line\">  this.state = &#123;</span><br><span class=\"line\">    // &quot;DataSource&quot; is some global data source</span><br><span class=\"line\">    comments: DataSource.getComments()</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">componentDidMount() &#123;</span><br><span class=\"line\">  // Subscribe to changes</span><br><span class=\"line\">  DataSource.addChangeListener(this.handleChange);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">componentWillUnmount() &#123;</span><br><span class=\"line\">  // Clean up listener</span><br><span class=\"line\">  DataSource.removeChangeListener(this.handleChange);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">handleChange = () =&gt; &#123;</span><br><span class=\"line\">  // Update component state whenever the data source changes</span><br><span class=\"line\">  this.setState(&#123;</span><br><span class=\"line\">    comments: DataSource.getComments()</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">render() &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &#123;this.state.comments.map((comment) =&gt; (</span><br><span class=\"line\">        &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt;</span><br><span class=\"line\">      ))&#125;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Sau đó, ta lại viết một component sử dụng cho việc nhận dữ liệu là các bài viết để hiện thị danh sách, với một pattern tương tự:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class BlogPost extends React.Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state = &#123;</span><br><span class=\"line\">      blogPost: DataSource.getBlogPost(props.id)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    DataSource.addChangeListener(this.handleChange);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentWillUnmount() &#123;</span><br><span class=\"line\">    DataSource.removeChangeListener(this.handleChange);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleChange = () =&gt; &#123;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      blogPost: DataSource.getBlogPost(this.props.id)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return &lt;TextBlock text=&#123;this.state.blogPost&#125; /&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Sau khi đọc xong 2 component trên, ta có thể thấy rằng 2 component trên đang thực hiện một quy trình tương tự:</p>\n<ul>\n<li>Ở componentDidMount, truyền hàm khi thực hiện thay đổi handleChange cho DataSource.</li>\n<li>Trong hàm handleChange thực hiện việc setState khi dữ liệu thay đổi.</li>\n<li>Ở componentWillUnmount, thực hiện bỏ hàm handleChange.</li>\n</ul>\n<p>Ta có thể tưởng tượng với một ứng dụng lớn, việc lặp lại này được thực hiện liên tục. Do vậy ta sẽ muốn một cách trừu tượng hóa để cho phép ta có thể định nghĩa logic ở một nơi và chia sẻ chúng cho nhiều compoment khác. Và chính điều này làm cho higher-order components nổi trội hơn cả.</p>\n<p>Chúng ta có thể viết một hàm mà tạo ra các component như là CommentList và BlogPost nhận thông tin từ DataSource. Nó sẽ nhận đối số là một component con:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const CommentListWithSubscription = withSubscription(</span><br><span class=\"line\">  CommentList,</span><br><span class=\"line\">  (DataSource) =&gt; DataSource.getComments()</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">const BlogPostWithSubscription = withSubscription(</span><br><span class=\"line\">  BlogPost,</span><br><span class=\"line\">  (DataSource, props) =&gt; DataSource.getBlogPost(props.id)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Hàm này nhận 2 đối số, một là component được gói vào, hai là hàm lấy dữ liệu mà ta muốn.</p>\n<p>Khi CommentListWithSubscription và BlogPostWithSubscription được render thì CommentList và BlogPost sẽ nhận dữ liệu từ prop:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function withSubscription(WrappedComponent, selectData) &#123;</span><br><span class=\"line\">  return class extends React.Component &#123;</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">      super(props);</span><br><span class=\"line\">      this.state = &#123;</span><br><span class=\"line\">        data: selectData(DataSource, props)</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">      DataSource.addChangeListener(this.handleChange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentWillUnmount() &#123;</span><br><span class=\"line\">      DataSource.removeChangeListener(this.handleChange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleChange = () =&gt; &#123;</span><br><span class=\"line\">      this.setState(&#123;</span><br><span class=\"line\">        data: selectData(DataSource, this.props)</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      return &lt;WrappedComponent data=&#123;this.state.data&#125; &#123;...this.props&#125; /&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Note that an HOC doesn’t modify the input component, nor does it use inheritance to copy its behavior. Rather, an HOC composes the original component by wrapping it in a container component. An HOC is a pure function with zero side-effects.</p>\n<p>And that’s it! The wrapped component receives all the props of the container, along with a new prop, data, which it uses to render its output. The HOC isn’t concerned with how or why the data is used, and the wrapped component isn’t concerned with where the data came from.</p>\n<p>Cần nhớ một điều là HOC không chỉnh sửa, làm khác đi component đầu vào mà nó chỉ kế thừa các hành vi của component đó.</p>\n<p>Component được gói vào nhận tất các props của container, với props nó có thể sử dụng để render ra nội dung mà mình mong muốn. HOC không liên quan đến việc dữ liệu được sử dụng như thế nào, từ đâu, và component được gói vào cũng không liên quan đến dữ liệu được truyền từ đâu.</p>\n<h3 id=\"Dung-thay-doi-component-goc-hay-soan-lai-component\"><a href=\"#Dung-thay-doi-component-goc-hay-soan-lai-component\" class=\"headerlink\" title=\"Đừng thay đổi component gốc, hãy soạn lại component\"></a>Đừng thay đổi component gốc, hãy soạn lại component</h3><p>Ví dụ ta có 1 HOC chỉ in ra props và trả về chính component đầu vào:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function logProps(InputComponent) &#123;</span><br><span class=\"line\">  InputComponent.prototype.componentWillReceiveProps(nextProps) &#123;</span><br><span class=\"line\">    console.log(&apos;Current props: &apos;, this.props);</span><br><span class=\"line\">    console.log(&apos;Next props: &apos;, nextProps);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return InputComponent;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const EnhancedComponent = logProps(InputComponent);</span><br></pre></td></tr></table></figure>\n<p>Có một số vấn đề ở đây. Thứ nhất InputComponent không thể sử dụng lại một cách riêng biệt với EnhancedComponent. Quan trọng hơn nữa, nếu ta muốn sử dụng một HOC khác có EnhancedComponent thì cũng sẽ thay đổi hàm componentWillReceiveProps của HOC đầu tiên, vì vậy ta cần phải biết ta đang implement cái gì để tránh conflict với những HOC khác.</p>\n<p>Thay vì thay đổi, ta nên sử dụng composition bằng việc gói component đầu vào bên trong một container:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function logProps(WrappedComponent) &#123;</span><br><span class=\"line\">  return class extends React.Component &#123;</span><br><span class=\"line\">    componentWillReceiveProps(nextProps) &#123;</span><br><span class=\"line\">      console.log(&apos;Current props: &apos;, this.props);</span><br><span class=\"line\">      console.log(&apos;Next props: &apos;, nextProps);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      return &lt;WrappedComponent &#123;...this.props&#125; /&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>HOC này có chức năng tương tự như HOC ở bên trên (đã bị thay đổi) trong khi tránh được việc thay đổi, nguy cơ tiềm ẩn. This HOC has the same functionality as the mutating version while avoiding the potential for clashes. It works equally well with class and functional components. And because it’s a pure function, it’s composable with other HOCs, or even with itself.</p>\n<p>You may have noticed similarities between HOCs and a pattern called container components. Container components are part of a strategy of separating responsibility between high-level and low-level concerns. Containers manage things like subscriptions and state, and pass props to components that handle things like rendering UI. HOCs use containers as part of their implementation. You can think of HOCs as parameterized container component definitions.</p>\n<div style=\"text-align: right\"><strong>Nguồn: Viblo</strong></div>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjwerksop0001a4su8d0g5w53","tag_id":"cjwerksor0002a4su55iqs1au","_id":"cjwerksos0003a4su6t17udh4"}],"Tag":[{"name":"lalala","_id":"cjwerksor0002a4su55iqs1au"}]}}